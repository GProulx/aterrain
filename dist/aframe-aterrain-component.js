/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/all.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/ImageServer.js":
/*!****************************!*\
  !*** ./src/ImageServer.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n\n///\n/// BingImageProvider - fetch tiles directly from Bing on demand as threejs materials\n///\n/// TODO - caches images but never flushes them - should flush old images\n/// TODO - the key is hardcoded - should be supplied by caller\n///\n\nclass BingImageProvider {\n\n  constructor() {\n    this.cached = {};\n  }\n\n  readyPromise(resolve) {\n    let scope = this;\n    if(scope.imageurl) {\n      resolve();\n      return;\n    }\n    let metadata = \"https://dev.virtualearth.net/REST/V1/Imagery/Metadata/Aerial?output=json&include=ImageryProviders&key=RsYNpiMKfN7KuwZrt8ur~ylV3-qaXdDWiVc2F5NCoFA~AkXwps2-UcRkk2L60K5qBy5kPnTmwvxdfwl532NTheLdFfvYlVJbLnNWG1iC-RGL\";\n    fetch(metadata).then(response => { return response.json() }).then( json => {\n      let subdomains = json.resourceSets[0].resources[0].imageUrlSubdomains;\n      scope.subdomain = subdomains[~~(subdomains.length * Math.random())];\n      scope.imageurl = json.resourceSets[0].resources[0].imageUrl;\n      scope.imageurl = scope.imageurl.replace(\"http\", \"https\");\n      scope.imageurl = scope.imageurl.replace(\"{culture}\", \"en-US\");\n      scope.imageurl = scope.imageurl.replace(\"{subdomain}\",scope.subdomain);\n      scope.imageurl = scope.imageurl.replace(\"jpeg\", \"png\");\n      resolve();\n    });\n  }\n\n  quadkey(x, y, z) {\n    let quadKey = [];\n    for (var i = z; i > 0; i--) {\n      var digit = '0';\n      var mask = 1 << (i - 1);\n      if ((x & mask) != 0) {\n          digit++;\n      }\n      if ((y & mask) != 0) {\n          digit++;\n          digit++;\n      }\n      quadKey.push(digit);\n    }\n    return quadKey.join('');\n  }\n\n  requestImage(x,y,lod) {\n    let scope = this;\n\n    let key = x + \"-\" + y + \"-\" + lod;\n    let c = scope.cached[key];\n    if(c) {\n      return new Promise(function(resolve,reject) {\n        resolve(c);\n      });\n    }\n\n    return new Promise(function(resolve,reject) {\n      let quadkey = scope.quadkey(x,y,lod);\n      let url = scope.imageurl.replace(\"{quadkey}\", quadkey);\n      let image = new Image();\n      image.onload = unused => {\n        scope.cached[key] = image;\n        resolve(image);\n      }\n      fetch(url).then(response => { return response.blob(); }).then( blob => {\n        image.url = url;\n        image.src = URL.createObjectURL(blob);\n      });\n    });\n  }\n}\n\n///\n/// ImageServer returns images on demand that match the terrain tile boundaries.\n///\n/// TODO Cesium access token should be settable\n/// TODO Code is over-specialized around Bing Images + Cesium Elevation Tiles - but hard to generalize trivially.\n///\n\nclass ImageServer {\n\n  constructor() {\n    this.data = {};\n    this.data.debug = true;\n    //this.data.mapStyle = Cesium.BingMapsStyle.AERIAL;\n    this.data.source = 0;\n    if(this.data.source == 0) {\n      // bypass cesium\n      this.imageProvider = new BingImageProvider();\n    } else if(this.data.source == 1) {\n       // cesium for sf area - Something seems to be not working with this provider although it's the one I'd prefer to use right now - mar 1 2018\n       this.data.CesiumionAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlYmI0ZmY0My1hOTg5LTQzNWEtYWRjNy1kYzYzNTM5ZjYyZDciLCJpZCI6NjksImFzc2V0cyI6WzM3MDQsMzcwMywzNjk5LDM2OTNdLCJpYXQiOjE1MTY4MzA4ODZ9.kM-JnlG-00e7S_9fqS_QpXYTg7y5-cIEcZEgxKwRt5E';\n       this.data.url = 'https://beta.cesium.com/api/assets/3693?access_token=' + this.data.CesiumionAccessToken;\n       this.imageProvider = new Cesium.createTileMapServiceImageryProvider(this.data);\n    } else if(this.data.source == 2) {\n      // Cesium Bing abstraction in general - works ok although LOD is off by one?\n      this.data.key = 'RsYNpiMKfN7KuwZrt8ur~ylV3-qaXdDWiVc2F5NCoFA~AkXwps2-UcRkk2L60K5qBy5kPnTmwvxdfwl532NTheLdFfvYlVJbLnNWG1iC-RGL';\n      this.data.url = 'https://dev.virtualearth.net',\n      this.imageProvider = new Cesium.BingMapsImageryProvider(this.data);\n    }\n  }\n\n  ready(callback) {\n    // TODO examine why do the readypromises differ?\n    if(this.data.source == 0) {\n      this.imageProvider.readyPromise(callback);\n    } else {\n      Cesium.when(this.imageProvider.readyPromise).then(callback);\n    }\n  }\n\n  // this method calculates the image tile and fractional component (ie which pixel) of the image tile to fetch\n  projection2tile(scheme,image_lod,y) {\n    // which tile in the y axis - and retain fractional pixel pos\n    let lat = scheme.rect.north - y*scheme.degrees_latrad/256; // range PI/2 to -PI/2\n    // https://msdn.microsoft.com/en-us/library/bb259689.aspx -> no data past these points (I want max Y to be within the previous tile)\n    if(lat >= 1.48442222975) lat = 1.48442222974;\n    if(lat <= -1.48442222975) lat = -1.48442222974;\n    let sinLat = Math.sin(lat);\n    let tileY = (0.5 - Math.log((1 + sinLat) / (1 - sinLat)) / (4 * Math.PI)) * image_lod;\n    return tileY;\n  }\n\n  provideImageProjected(scheme,callback) {\n\n    // get image tiles at one level deeper than terrain tiles to take advantage of x lining up\n    let image_lod = Math.pow(2,scheme.lod+1);\n\n    // where is the top and bottom tile?\n    let ty1 = this.projection2tile(scheme,image_lod,0,0);\n    let ty2 = this.projection2tile(scheme,image_lod,255,255);\n    let tx1 = scheme.xtile;\n\n    // load entire range of tiles\n    let promises = [];\n    for(let i = Math.floor(ty1);i<=Math.floor(ty2);i++) {\n      let p = this.imageProvider.requestImage(tx1,i,scheme.lod+1);\n      promises.push(p);\n    }\n\n    // get canvas to paint to for final output\n    // TODO may as well put this indie the promise\n    let canvas = this.canvas_new();\n\n    // Paint once loaded\n    Promise.all(promises).then(results => {\n\n      // convert the img to something that can be read and written\n      if(!results.length) {\n        console.error(\"Image server no image content error 1\");\n        return;        \n      }\n\n      // a canvas is required per image source in order to get at the pixels\n      for(let i = 0; i < results.length;i++) {        \n        if(typeof results[i] == 'undefined' || !results[i]) {\n          console.error(\"Image server no image content error 2\");\n          return;\n        }\n        this.canvas_from_image(results[i]);\n      }\n\n      // walk the sources and copy pixels to a target - this is labor intensive\n      for(let y = 0;y<256;y++) {\n\n        // get reverse mercator pixel location (only y is needed)\n        let txy = this.projection2tile(scheme,image_lod,y);\n\n        // get that tile (offset from the set of tiles we happen to have)\n        let image = results[Math.floor(txy)-Math.floor(ty1)];\n\n        // get y in tile\n        let yy = Math.floor(txy*256) & 255;\n\n        // copy that row (there is no horizontal reprojection only vertical)\n        // TODO this could be optimized such as by not setting the alpha here and copying uints\n        for(let x = 0; x<256;x++) {\n          canvas.imageData.data[(y*256+x)*4+0] = image.imageData.data[(yy*256+x)*4+0];\n          canvas.imageData.data[(y*256+x)*4+1] = image.imageData.data[(yy*256+x)*4+1];\n          canvas.imageData.data[(y*256+x)*4+2] = image.imageData.data[(yy*256+x)*4+2];\n          canvas.imageData.data[(y*256+x)*4+3] = 255;\n        }\n      }\n\n      // return to the caller\n      callback(this.canvas_to_material_from_imagedata(canvas));\n    });\n  }\n\n  provideImageUnprojectedUnused(scheme,callback) {\n    // here is a version of the image mapper that doesn't do any projection\n    let x = scheme.xtile;\n    let y = scheme.ytile;\n    let lod = scheme.lod;\n    let p1 = this.imageProvider.requestImage(x,y+y,lod+1);\n    let p2 = this.imageProvider.requestImage(x,y+y+1,lod+1);\n    Promise.all([p1,p2]).then( results => {\n      let canvas = this.canvas_new();\n      this.canvas_paint(canvas,results[0],{x1:0,y1:0,x2:256,y2:128});\n      this.canvas_paint(canvas,results[1],{x1:0,y1:128,x2:256,y2:128});\n      callback(this.canvas_to_material(canvas));\n    }, function(error) {\n      console.error(error);\n    });\n  }\n\n  provideImage(scheme,callback) {\n    this.provideImageProjected(scheme,callback);\n  }\n\n  //////////////////////////////////////////////////////////// canvas assistance\n\n  canvas_new() {\n    let canvas = document.createElement('canvas');\n    canvas.id = \"canvas\";\n    canvas.width = 256;\n    canvas.height = 256;\n    canvas.ctx = canvas.getContext(\"2d\");\n    canvas.ctx.fillStyle = \"#ff0000\";\n    canvas.ctx.fillRect(0,0,256,256);\n    canvas.imageData = canvas.ctx.getImageData(0,0,256,256);\n    //  var buf = new ArrayBuffer(imageData.data.length);\n    //  var buf8 = new Uint8ClampedArray(buf);\n    //  var data = new Uint32Array(buf);\n    return canvas;\n  }\n\n  canvas_paint(canvas,image,extent) {\n    let debug = this.data.debug;\n    canvas.ctx.drawImage(image,extent.x1,extent.y1,extent.x2,extent.y2);\n    if(debug) {\n      let ctx = canvas.ctx;\n      ctx.beginPath();\n      ctx.lineWidth=\"6\";\n      ctx.strokeStyle=\"red\";\n      ctx.rect(0,0,255,255); \n      ctx.stroke();\n    }\n    return canvas;\n  }\n\n  canvas_from_image(image) {\n    if(image.canvas) return;\n    image.canvas = document.createElement('canvas');\n    image.canvas.width = 256;\n    image.canvas.height = 256;\n    image.canvas.ctx = image.canvas.getContext(\"2d\");\n    image.canvas.ctx.fillStyle = \"#ffff00\";\n    image.canvas.ctx.fillRect(0,0,256,256);\n    image.canvas.ctx.drawImage(image,0,0,256,256);\n    image.imageData = image.canvas.ctx.getImageData(0,0,256,256);\n  }\n\n  canvas_to_material(canvas) {\n    //let material = new THREE.MeshPhongMaterial( { color:0xffffff, wireframe:false });\n    let material = new THREE.MeshLambertMaterial( { color:0xffffff, wireframe:false }); //shading: THREE.SmoothShading});\n    material.map = new THREE.Texture(canvas);\n    material.map.needsUpdate = true;\n    return material;\n  }\n\n  canvas_to_material_from_imagedata(canvas) {\n    // data[y * canvasWidth + x] = 0xff00000+b<<16+g<<8+r;\n    // imageData.data.set(buf8);\n    canvas.ctx.putImageData(canvas.imageData, 0, 0);\n    return this.canvas_to_material(canvas);\n  }\n\n}\n\n///\n/// Singelton convenience handles\n/// TODO an AFrame System could do this https://aframe.io/docs/0.7.0/core/systems.html\n///\n\nImageServer.instance = function() {\n  if(ImageServer.imageServer) return ImageServer.imageServer;\n  ImageServer.imageServer = new ImageServer();\n  return ImageServer.imageServer;\n};\n\n\n// es6 glue\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ImageServer);\n\n\n\n//# sourceURL=webpack:///./src/ImageServer.js?");

/***/ }),

/***/ "./src/TileServer.js":
/*!***************************!*\
  !*** ./src/TileServer.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ImageServer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageServer.js */ \"./src/ImageServer.js\");\n\n\n\n///\n/// TileServer is intended to be a prototypical elevation tile provider - it wraps Cesium tiles\n/// The philosophy here is that if you want to implement a different data source then you write a separate class.\n/// TODO change this to an aframe-system\n/// TODO ellipsoid is spherical and should be oblate\n\nclass TileServer  {\n \n  constructor() {\n\n    // cesium terrain is not in mercator -> https://cesiumjs.org/releases/1.2/Build/Documentation/GeographicTilingScheme.html\n\n    this.data = {};\n    this.data.ellipsoid = new Cesium.Ellipsoid(1,1,1);\n    this.data.requestVertexNormals = true;\n    this.data.url = \"https://assets.agi.com/stk-terrain/v1/tilesets/world/tiles\";\n\n    // TODO study -> there seem to be more missing tiles here - don't use this source for now?\n    //this.data.CesiumionAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlYmI0ZmY0My1hOTg5LTQzNWEtYWRjNy1kYzYzNTM5ZjYyZDciLCJpZCI6NjksImFzc2V0cyI6WzM3MDQsMzcwMywzNjk5LDM2OTNdLCJpYXQiOjE1MTY4MzA4ODZ9.kM-JnlG-00e7S_9fqS_QpXYTg7y5-cIEcZEgxKwRt5E';\n    //this.data.url = 'https://beta.cesium.com/api/assets/3699?access_token=' + this.data.CesiumionAccessToken;\n\n    this.terrainProvider = new Cesium.CesiumTerrainProvider(this.data);\n\n  }\n\n  ready(callback) {\n    Cesium.when(this.terrainProvider.readyPromise).then( unused => {\n      _ImageServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ready(callback);\n    });\n  }\n\n  getGround(data,callback) {\n    // TODO replace with custom elevation derivation - see findClosestElevation() - but it needs to interpolate still\n    let scope = this;\n    let poi = Cesium.Cartographic.fromDegrees(data.lon,data.lat);\n    Cesium.sampleTerrain(scope.terrainProvider,data.lod,[poi]).then(function(groundResults) {\n      callback(groundResults[0].height);\n    });\n  }\n\n  findClosestElevation(scheme) {\n    // TODO may want to actually interpolate rather than merely taking the closest elevation...\n    let tile = scheme.tile;\n    let distance = Number.MAX_SAFE_INTEGER;\n    let best = 0;\n    for (let i=0; i<tile._uValues.length; i++) {\n      let x = (scheme.x-scheme.xtile)*32767 - tile._uValues[i]; // compiler will optimize\n      let y = (scheme.y-scheme.ytile)*32767 - tile._vValues[i];\n      if(x*x+y*y < distance) {\n        distance = x*x+y*y;\n        best = (((tile._heightValues[i]*(tile._maximumHeight-tile._minimumHeight))/32767.0)+tile._minimumHeight);\n      }\n    }\n    return best;\n  }\n\n  getRadius() {\n    return 63727982.0;\n  }\n\n  getCircumference() {\n    return 400414720.159; // 2*Math.PI*this.getRadius();\n  }\n\n  elevation2lod(d) {\n    let c = this.getCircumference();\n    // truncate reasonable estimations for lod\n    if(d < 1) d = 1;\n    if(d > c/2) d = c/2;\n    // even a small camera fov of 45' would show the entire circumference of the earth at a distance of circumference/2 if the earth was flattened\n    // the visible area is basically distance * 2 ... so  ... number of tiles = circumference / (distance*2)\n    // visible coverage is 2^(lod+1) = number of tiles  or .... 2^(lod+1) = c / (d*2) ... or ... \n    // also see https://gis.stackexchange.com/questions/12991/how-to-calculate-distance-to-ground-of-all-18-osm-zoom-levels/142555#142555\n    let lod = Math.floor(Math.log2(c/(d*2)));\n    // truncate\n    if(lod < 0) lod = 0;\n    if(lod > 19) lod = 19;\n    return lod;\n  }\n\n  scheme_elaborate(data) {\n\n    // This commented out approach is the more correct way get below details from an arbitrary cesium terrain provider - but requires waiting for ready event\n    // this.terrainProvider.tilingScheme.getNumberOfXTilesAtLevel(lod) * (180+lon) / 360;\n    // this.terrainProvider.tilingScheme.getNumberOfYTilesAtLevel(lod) * ( 90-lat) / 180;\n    // let poi = Cesium.Cartographic.fromDegrees(lon,lat);\n    // let xy = this.terrainProvider.tilingScheme.positionToTileXY(poi,lod);\n    // scheme.rect = this.terrainProvider.tilingScheme.tileXYToRectangle(xy.x,xy.y,lod);\n\n    let scheme = {};\n\n    let lat = scheme.lat = data.lat;\n    let lon = scheme.lon = data.lon;\n    let lod = scheme.lod = data.lod;\n    let radius = scheme.radius = data.radius;\n\n    // get number of tiles wide and tall - hardcoded to cesium terrain tiles TMS format\n    scheme.w = Math.pow(2,lod+1);\n    scheme.h = Math.pow(2,lod);\n\n    // get tile index with fractional exact position\n    scheme.x = (180+lon) * scheme.w / 360;\n    scheme.y = ( 90-lat) * scheme.h / 180;\n\n    // get tile index (remove fraction)\n    scheme.xtile = Math.floor(scheme.x);\n    scheme.ytile = Math.floor(scheme.y);\n\n    // calculate uuid for tile\n    scheme.uuid = \"tile-\"+scheme.xtile+\"-\"+scheme.ytile+\"-\"+lod;\n\n    // position in radians\n    scheme.lonrad = scheme.lon * Math.PI / 180;\n    scheme.latrad = scheme.lat * Math.PI / 180;\n\n    // extents in radians\n    let a = ( (scheme.xtile + 0) * 360 / scheme.w - 180   ) * Math.PI / 180;\n    let b = ( (scheme.xtile + 1) * 360 / scheme.w - 180   ) * Math.PI / 180;\n    let c = ( - (scheme.ytile+0) * 180 / scheme.h + 90    ) * Math.PI / 180;\n    let d = ( - (scheme.ytile+1) * 180 / scheme.h + 90    ) * Math.PI / 180;\n    scheme.rect = { west:a, south:d, east:b, north:c };\n\n    // degrees of coverage in radiams\n    scheme.degrees_lonrad = scheme.rect.east-scheme.rect.west;\n    scheme.degrees_latrad = scheme.rect.north-scheme.rect.south;\n\n    // degrees of coverage\n    scheme.degrees_lon = 360 / scheme.w; \n    scheme.degrees_lat = 180 / scheme.h;\n\n    // TODO make this a parameter\n    scheme.building_url = \"https://s3.amazonaws.com/cesium-dev/Mozilla/SanFranciscoGltf15Gz/\"+scheme.lod+\"/\"+scheme.xtile+\"/\"+scheme.ytile+\".gltf\";\n\n    // convenience values\n    scheme.width_world = this.getCircumference();\n    scheme.width_tile_flat = scheme.width_world / scheme.w;\n    scheme.width_tile_lat = scheme.width_tile_flat * Math.cos(data.lat * Math.PI / 180);\n\n    return scheme;\n  }\n\n  ll2v(latrad,lonrad,r=1) {\n    // given a latitude and longitude in radians return a vector\n    let phi = Math.PI/2-latrad;\n    let theta = Math.PI/2+lonrad;\n    let x = -r*Math.sin(phi)*Math.cos(theta);\n    let z = r*Math.sin(phi)*Math.sin(theta);\n    let y = r*Math.cos(phi);\n    return new THREE.Vector3(x,y,z);\n  }\n\n  /*\n  toGeometryUnusedTest(scene) {\n\n    // some test code to look at how cesium was building the Gudermannian \n\n    // prepare to build a portion of the hull of the surface of the planet - this will be a curved mesh of x by y resolution (see below)\n    let geometry = new THREE.Geometry();\n\n    // scale is arbitrary\n    let scale = 256;\n\n    // stride across the hull at this x resolution\n    let xs = 16;\n\n    // stride across the hull at this y resolution\n    let ys = 16;\n\n    // here is the code from https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Scene/ImageryLayer.js#L1026\n    // just wanted to see what the fractional values were over some extent\n\n    var sinLatitude = Math.sin(scheme.rect.south);\n    var southMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n\n    sinLatitude = Math.sin(scheme.rect.north);\n    var northMercatorY = 0.5 * Math.log((1 + sinLatitude) / (1 - sinLatitude));\n    var oneOverMercatorHeight = 1.0 / (northMercatorY - southMercatorY);\n\n    // build vertices (for a given x,y point on the hull calculate the longitude and latitude of that point)\n    for(let y = 0; y <= scale; y+=ys) {\n     // for(let x = 0; x <= scale; x+=xs) {\n        let fraction = y / 255;\n        let latitude = (scheme.rect.south-scheme.rect.north) * fraction;\n         sinLatitude = Math.sin(latitude);\n        let mercatorY = 0.5 * Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude));\n        let mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\n        console.log(\"lat = \"+latitude+\" sinlat=\"+sinLatitude+\" mercfract=\" + mercatorFraction);\n      //}\n    }\n  }\n  */\n\n  toGeometryIdealized(scheme) {\n\n    // prepare to build a portion of the hull of the surface of the planet - this will be a curved mesh of x by y resolution (see below)\n    let geometry = new THREE.Geometry();\n\n    // scale is arbitrary\n    let scale = 256;\n\n    // stride across the hull at this x resolution\n    let xs = 16;\n\n    // stride across the hull at this y resolution\n    let ys = 16;\n\n    // build vertices (for a given x,y point on the hull calculate the longitude and latitude of that point)\n    for(let y = 0; y <= scale; y+=ys) {\n      for(let x = 0; x <= scale; x+=xs) {\n\n        // x position for vertex within hull\n        let lonrad = scheme.degrees_lonrad * x / scale + scheme.rect.west;\n\n        // y position for vertex within hull\n        let latrad = scheme.rect.north - scheme.degrees_latrad * y / scale;\n\n        //if(this.guder) { latrad = gudermannian_radians(latrad); }\n\n        let radius = scheme.radius;\n        let v = this.ll2v(latrad,lonrad,radius);\n        geometry.vertices.push(v);\n      }\n    }\n    // connect the dots\n    for(let y = 0, v =0; y < scale; y+=ys) {\n      for(let x = 0; x < scale; x+=xs) {\n        geometry.faces.push(new THREE.Face3(v+1,v,v+scale/xs+1));\n        geometry.faces.push(new THREE.Face3(v+1,v+scale/xs+1,v+scale/xs+1+1));\n        v++;\n      }\n      v++;\n    }\n    // uvs\n    geometry.faceVertexUvs[0] = [];\n    for(let y = 0, v = 0; y < scale; y+=ys) {\n      for(let x = 0; x < scale; x+=xs) {\n        let vxa = x/scale;\n        let vya = y/scale;\n        let vxb = (x+xs)/scale;\n        let vyb = (y+ys)/scale;\n        vya = 1-vya;\n        vyb = 1-vyb;\n        geometry.faceVertexUvs[0].push([ new THREE.Vector2(vxb,vya), new THREE.Vector2(vxa,vya), new THREE.Vector2(vxa,vyb) ]);\n        geometry.faceVertexUvs[0].push([ new THREE.Vector2(vxb,vya), new THREE.Vector2(vxa,vyb), new THREE.Vector2(vxb,vyb) ]);\n      }\n    }\n    geometry.uvsNeedUpdate = true;\n    // normals\n    geometry.computeVertexNormals();\n    geometry.computeFaceNormals();\n    return geometry;\n  }\n\n  toGeometry(scheme) {\n    let tile = scheme.tile;\n    let geometry = new THREE.Geometry();\n    let earth_radius = this.getRadius();\n    // build vertices on the surface of a globe given a linear latitude and longitude series of stepped values -> makes evenly distributed spherically points\n    for (let i=0; i<tile._uValues.length; i++) {\n      let lonrad = tile._uValues[i]/32767*scheme.degrees_lonrad + scheme.rect.west;\n      let latrad = tile._vValues[i]/32767*scheme.degrees_latrad + scheme.rect.south;\n      let elevation = (((tile._heightValues[i]*(tile._maximumHeight-tile._minimumHeight))/32767.0)+tile._minimumHeight);\n      let v = this.ll2v(latrad,lonrad,(earth_radius+elevation)*scheme.radius/earth_radius);\n      geometry.vertices.push(v);\n    }\n    // vertices to faces\n    for (let i=0; i<tile._indices.length-1; i=i+3) {\n      geometry.faces.push(new THREE.Face3(tile._indices[i], tile._indices[i+1], tile._indices[i+2]));\n    }\n    // face vertices to linear distribution uv map\n    let faces = geometry.faces;\n    geometry.faceVertexUvs[0] = [];\n    for (let i = 0; i < faces.length ; i++) {\n      let vxa = tile._uValues[faces[i].a]/32767;\n      let vya = tile._vValues[faces[i].a]/32767;\n      let vxb = tile._uValues[faces[i].b]/32767;\n      let vyb = tile._vValues[faces[i].b]/32767;\n      let vxc = tile._uValues[faces[i].c]/32767;\n      let vyc = tile._vValues[faces[i].c]/32767;\n      geometry.faceVertexUvs[0].push([ new THREE.Vector2(vxa,vya), new THREE.Vector2(vxb,vyb), new THREE.Vector2(vxc,vyc) ]);\n    }\n    geometry.uvsNeedUpdate = true;\n    // normals\n    geometry.computeVertexNormals();\n    geometry.computeFaceNormals();\n    return geometry;\n  }\n\n  produceTile(data,callback) {\n    let scheme = this.scheme_elaborate(data);\n    this.imageProvider = _ImageServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance(); // not the most elegant... TODO move? have a parent wrapper for both providers?\n    this.imageProvider.provideImage(scheme, material => {\n      scheme.material = material;\n      Cesium.when(this.terrainProvider.requestTileGeometry(scheme.xtile,scheme.ytile,scheme.lod),tile => {\n        scheme.tile = tile;\n        scheme.geometry = this.toGeometry(scheme); // this.toGeometryIdealized(scheme);\n        scheme.mesh = new THREE.Mesh(scheme.geometry,scheme.material);\n        callback(scheme);\n      });\n    });\n  }\n}\n\n///\n/// Singelton convenience handles\n/// TODO an AFrame System could do this https://aframe.io/docs/0.7.0/core/systems.html\n///\n\nTileServer.instance = function() {\n  if(TileServer.tileServer) return TileServer.tileServer;\n  TileServer.tileServer = new TileServer();\n  return TileServer.tileServer;\n};\n\n// es6 glue\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (TileServer);\n\n\n\n//# sourceURL=webpack:///./src/TileServer.js?");

/***/ }),

/***/ "./src/a-building.js":
/*!***************************!*\
  !*** ./src/a-building.js ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TileServer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileServer.js */ \"./src/TileServer.js\");\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\n\n\n///\n/// a-building\n///\n/// wrap cesium 3d tiles and adjust position and size\n///\n/// TODO buildings are still not centered perfectly\n/// TODO rather than relying on TileServer a new lower level math library could be defined\n\n\nAFRAME.registerComponent('a-building', {\n  schema: {\n       lat: {type: 'number', default: 0},\n       lon: {type: 'number', default: 0},\n       lod: {type: 'number', default: 0},\n    radius: {type: 'number', default: 1},\n  },\n  init: function () {\n    let GLTFLoader = new AFRAME.THREE.GLTFLoader();\n    let scope = this;\n    let data = scope.data;\n    let scheme = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().scheme_elaborate(data);\n    GLTFLoader.load(scheme.building_url,function(gltf) {\n      scope.el.setObject3D('mesh',gltf.scene);\n      let world_radius = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().getRadius() / 10; // unsure why this is TODO\n      let s = data.radius/world_radius;\n      scope.el.object3D.scale.set(s,s,s);\n      // fix building rotation to reflect frame of reference here (they are pre-rotated for a different frame of reference)\n      scope.el.object3D.rotation.set(0,-Math.PI/2,0);\n      // fix building longitude and latitude centering to reflect tile center\n      let lat = scheme.rect.south+scheme.degrees_latrad/2;\n      let lon = scheme.rect.west+scheme.degrees_lonrad/2;\n      let v = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ll2v(lat,lon,scheme.radius);\n      scope.el.object3D.position.set(v.x,v.y,v.z);\n    });\n  }\n});\n\n\n\n//# sourceURL=webpack:///./src/a-building.js?");

/***/ }),

/***/ "./src/a-location.js":
/*!***************************!*\
  !*** ./src/a-location.js ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TileServer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileServer.js */ \"./src/TileServer.js\");\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\n\n\n///\n/// A-location\n/// If this is inside an a-terrain then the child will be on the surface at the specified latitude and longitude\n///\n/// TODO should peek at the parent to find the radius rather than hard coded\n/// TODO tileserver.scheme_elaborate could be moved to a lower level math module that everybody uses\n/// TODO there are still some size / scale issues that are incorrect\n///\n\nAFRAME.registerComponent('a-location', {\n  schema: {\n       lat: {type: 'number', default:  0},\n       lon: {type: 'number', default:  0},\n    radius: {type: 'number', default:  1},\n  },\n  init: function() {\n    let scheme = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().scheme_elaborate(this.data);\n    let v = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ll2v(scheme.latrad,scheme.lonrad,this.data.radius);\n    // TODO this approach is inelegant; it would be cleaner to apply the latitude and longitude rotations as done with rotating the world\n    this.el.object3D.position.set(v.x,v.y,v.z);\n    this.el.object3D.lookAt( new THREE.Vector3(0,0,0) );\n\n    // This would be cleaner - would avoid the lookat which is clumsy\n    //obj.rotation.set(0,0,0);\n    //var q = new THREE.Quaternion();\n    //q.setFromAxisAngle( new THREE.Vector3(0,1,0), THREE.Math.degToRad(-data.lon) );\n    // obj.quaternion.premultiply(q);\n    //q.setFromAxisAngle( new THREE.Vector3(1,0,0), THREE.Math.degToRad(data.lat) );\n    // obj.quaternion.premultiply(q);\n  },\n});\n\n\n\n//# sourceURL=webpack:///./src/a-location.js?");

/***/ }),

/***/ "./src/a-terrain.js":
/*!**************************!*\
  !*** ./src/a-terrain.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TileServer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileServer.js */ \"./src/TileServer.js\");\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\n\n\n///\n/// a-terrain\n///\n/// manufactures a-tile instances to cover an area of observed space as a sphere\n///\n\nAFRAME.registerComponent('a-terrain', {\n\n  schema: {\n        radius: {type: 'number', default:    1},     // radius of the world in game space\n           lat: {type: 'number', default:    0},     // latitude - where to center the world and where to fetch tiles from therefore\n           lon: {type: 'number', default:    0},     // longitude\n           lod: {type: 'number', default:    1},     // this is computed but left here since having a separate parent bucket/schema is a hassle\n     elevation: {type: 'number', default:    1},     // height above ground\n      observer: {type: 'string', default:   \"\"}      // id of camera or cameraRig - if there is not one then the lod has to be manually specified\n  },\n\n  ///\n  /// No need for more than one copy of component\n  /// \n  multiple: false,\n\n  // internal list of tiles for sweeper convenience\n  tiles: {},\n\n  // delay for startup - TODO probably a more elegant way to latch tick()\n  refreshState: 0,\n\n  ///\n  /// Init\n  ///\n  init: function() {\n    this.refreshState = 0;\n    _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ready( unused => {\n      this.refreshState = 1;\n    });\n  },\n\n  ///\n  /// tick at 60fps\n  ///\n  tick: function() {\n    // Ready?\n    if(!this.refreshState) {\n      return;\n    }\n    // Update level of detail based on viewing mode\n    this.updateView();\n    // Sweep old tiles if any\n    this.sweepTiles();\n  },\n\n  ///\n  /// Update view based on view mode\n  ///\n  updateView: function() {\n    if(this.data.observer.length > 0) {\n      this.updateView_Observer();\n    } else {\n      this.updateView_Origin();\n    }\n  },\n\n  ///\n  /// Generate surface tiles to provide a consistent view from the viewpoint of the supplied target or camera\n  /// In this style of view the observer could interpenetrate mountains\n  ///\n  updateView_Observer: function() {\n\n    // Find observer again every frame since it may change or just return\n    let observer = this.el.sceneEl.querySelector(\"#\"+this.data.observer);\n    if(!observer) {\n      return;\n    }\n\n    // Exit if no change\n    if(this.observer_position && observer.object3D.position.equals(this.observer_position)) {\n      return;\n    }\n    this.observer_position = observer.object3D.position.clone();\n\n    // How far is the target from the globe in the model distance?\n    let model_distance = this.el.object3D.position.distanceTo( this.observer_position );\n\n    // The observer does not know how high above the ellipsoid the current terrain elevation is - pick a number for now\n    // TODO ponder\n    let ground_value = 500;\n\n    // Right now we know the world radius ... code could be refactored to not need to know this TODO\n    let world_radius = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().getRadius();\n\n    // Given a model distance in model coordinates obtain an elevation in world coordinates;\n    this.data.elevation = model_distance * world_radius / this.data.radius - world_radius + ground_value;\n\n    // Recover latitude and longitude from observer\n    this.data.lat = -observer.object3D.rotation.x * 180.0 / Math.PI;\n    this.data.lon = observer.object3D.rotation.y * 180.0 / Math.PI;\n\n    // TODO mercator is giving us some trouble here - examine more later - constrain for now\n    if(this.data.lat > 85) this.data.lat = 85;\n    if(this.data.lat < -85) this.data.lat = -85;\n\n    // Generate appropriate tiles for this viewing vantage point\n    this.updateTiles();\n  },\n\n  ///\n  /// In this viewing style the camera position not used\n  /// the caller specifies a latitude and longitude and elevation\n  /// this code rotates the world so that that given lat/lon is facing due north\n  /// and then the surface of the planet is moved down to be at the origin\n  /// the net effect is that if there was a camera at the origin that that point should appear to be on the earths surface\n  ///\n  /// however there is another problem here which is that the world may be very very tiny - tiles at a given lod may be smaller than a single pixel\n  /// so the entire world has to also be scaled to a desired zoom level to see geometry in what appears to be a 1 = one meter kind of display\n  /// we do not want to scale the camera (we don't want to mess with the developers camera at all) so instead the world must be scaled\n  ///\n\n  updateView_Origin: function() {\n\n    let data = this.data;\n\n    // rotate the world such that the supplied lat, lon is at 0,0\n\n    let obj = this.el.object3D;\n    obj.rotation.set(0,0,0);\n\n    var q = new THREE.Quaternion();\n    q.setFromAxisAngle( new THREE.Vector3(0,1,0), THREE.Math.degToRad(-data.lon) );\n    obj.quaternion.premultiply(q);\n    q.setFromAxisAngle( new THREE.Vector3(1,0,0), THREE.Math.degToRad(data.lat) );\n    obj.quaternion.premultiply(q);\n\n    // deal with distance and tiles\n    let world_radius = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().getRadius();\n    let world_circumference = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().getCircumference();\n\n    // estimate level of detail ... \n    data.lod = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().elevation2lod(data.elevation);\n\n    let adjust_globe_elevation_relative_to_origin = function(groundValue) {\n      // the world surface should touch the origin\n      let distance = (world_radius+groundValue+data.elevation)*data.radius/world_radius;\n      // move earth surface here\n    //  obj.position.set(0,0,-distance);\n      console.log(\"for elevation \" + data.elevation + \" the lod is \" + data.lod + \" and ground is at \" + groundValue + \" rad=\"+data.radius + \" distance=\" + distance );\n    };\n\n\n   // quick set to avoid delays even if stale - ground level is not known yet but waiting for it causes visible delays\n    //if(data.groundLatched) {\n    //  adjust_globe_elevation_relative_to_origin(data.ground);\n    //}\n\n    // get ground height (has a delay)\n    _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().getGround(data,groundValue => {\n      if(!groundValue || groundValue <0) groundValue = 0;\n      data.ground = groundValue;\n      data.groundLatched = true;\n      adjust_globe_elevation_relative_to_origin(groundValue);\n    });\n\n    // Generate appropriate tiles for this viewing vantage point\n    this.updateTiles();\n  },\n\n  ///\n  /// Given some facts about a desired longitude and latitude and level of detail generate some tiles here\n  /// TODO the assumption here is that the player is looking straight down and the camera has an fov of 45' - this assumption is wrong.\n  ///\n\n  updateTiles: function() {\n\n    // re-estimate level of detail given an elevation\n    this.data.lod = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().elevation2lod(this.data.elevation);\n\n    // ask tile server for facts about a given latitude, longitude, lod\n    let scheme = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().scheme_elaborate(this.data);\n\n    // the number of tiles to fetch in each direction is a function of the camera fov (45') and elevation over the size of a tile at current lod\n    let count = Math.floor(this.data.elevation / scheme.width_tile_lat) + 1;\n\n    // TODO improve view strategy - render enough tiles to cover the degrees visible - regardless of current lod - however it depends on the camera fov being 45'\n    for(let i = -count;i<count+1;i++) {\n      for(let j = -count;j<count+1;j++) {\n        // TODO this is sloppy; there is a chance of a numerical error - it would be better to be able to ask for tiles by index as well as by lat/lon\n        let scratch = { lat:this.data.lat + scheme.degrees_lat * i, lon:this.data.lon + scheme.degrees_lon * j, lod:this.data.lod, radius:this.data.radius };\n        // hack terrible code TODO cough forever loop\n        while(scratch.lon < -180) scratch.lon += 360;\n        while(scratch.lon >= 180) scratch.lon -= 360;\n        while(scratch.lat < -90) scratch.lat += 180;\n        while(scratch.lat >= 90) scratch.lat -= 180;\n        // make tile\n        this.updateOrCreateTile(scratch);\n      }\n    }\n\n  },\n\n  ///\n  /// Satisfy that a given tile exists\n  ///\n\n  updateOrCreateTile: function(data) {\n    // find tile by uuid that would cover requested point latitude, longitude, lod\n    let scheme = _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().scheme_elaborate(data);\n    let uuid = scheme.uuid;\n    let element = this.el.querySelector(\"#\"+uuid);\n    if(element) {\n      element.setAttribute(\"visible\",true);\n      // not used - issue this when visible\n      // element.emit(\"a-tile:visible\", {lat:data.lat, lon: data.lon, lod:data.lod,id:uuid }, false);\n    } else {\n      // if not found then ask a tile to build itself in such a way that it covers the given latitude, longitude, lod\n      element = document.createElement('a-entity');\n      element.setAttribute('id',uuid);\n      element.setAttribute('a-tile',{lat:data.lat,lon:data.lon,lod:data.lod,radius:data.radius});\n      // set lod and loaded directly on the element right now because getAttribute() appears to sometimes not be set synchronously\n      element.lod = data.lod;\n      element.loaded = 0;\n      this.el.appendChild(element);\n    }\n    this.tiles[scheme.uuid] = element;\n  },\n\n  ///\n  /// Hide tiles that are not interesting if they are occluded by interesting tiles\n  ///\n\n  sweepTiles: function() {\n\n    let lod = this.data.lod;\n\n    // bail immediately and do not sweep if any tiles at the current lod are not ready\n    let keys = Object.keys(this.tiles);\n    for(let i = 0; i < keys.length; i++) {\n      let element = this.tiles[keys[i]];\n      if(element.lod == lod && element.loaded != 1) {\n        let properties = element.getAttribute('a-tile');\n        return;\n      }\n    };\n\n    // sweep other tiles that are not at current lod\n\n    for(let i = 0; i < keys.length; i++) {\n      let element = this.tiles[keys[i]];\n      if(element.lod != lod && element.getAttribute(\"visible\") != false) {\n        element.setAttribute(\"visible\",false); \n      }\n    };\n\n  },\n\n\n\n});\n\n/*\n\n- my strategy is to try leaving the camera at the origin\n\n- and to move the planet to the latitude and longitude desired - so that the camera views the world from that position\n\n- so i tell the planet a lat,lon,elevation - and no camera hints\n\n- because of level of detail, the system would render a fairly small part of the world depending on elevation...\n\n- this should be testable\n\n\n\n\n// i have an extremely large world and i can scale it down, and paint it at a position\n\n// i have \n\n// i want to basically\n\n// so if i want the system to be 1to1 then the radius has to be 1 to 1\n// - \n\n// - \n\n// for an elevation of 0 then the distance is what\n// \n// - i think you specify a latitude and longitude and elevation above the ground\n// - \n// a-terrain.js:245 for elevation 263727982 the lod is 0 and ground is at 1695.75032805823 rad=10\n\n \n */\n\n//# sourceURL=webpack:///./src/a-terrain.js?");

/***/ }),

/***/ "./src/a-tile.js":
/*!***********************!*\
  !*** ./src/a-tile.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _TileServer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TileServer.js */ \"./src/TileServer.js\");\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\n\n\n///\n/// a-tile\n/// A single tile as specified by the tileServer abstraction\n///\n\nAFRAME.registerComponent('a-tile', {\n  schema: {\n       lat: {type: 'number', default: 0},\n       lon: {type: 'number', default: 0},\n       lod: {type: 'number', default: 0},\n    radius: {type: 'number', default: 1},\n  },\n  init: function () {\n    let data = this.data;\n    if(!this.el)return;\n    // asynchronously begin loading process\n    _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().ready( unused => {\n      _TileServer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].instance().produceTile(data,scheme => {\n        // show tile\n        this.el.setObject3D('mesh',scheme.mesh);\n        // mark as complete\n        this.el.loaded = 1;\n        // not used - publish a general message that this tile is visible\n        // this.el.emit(\"a-tile:visible\", {lat:data.lat, lon: data.lon, lod:data.lod, id:this.el.id }, false);\n        // TODO it would be nice to know better if there were buildings without triggering an error\n        if(scheme.lod < 15) return;\n        let building = document.createElement('a-entity');\n        building.setAttribute('a-building',{ lat:data.lat, lon:data.lon, lod:15, radius:data.radius });\n        this.el.appendChild(building);\n      });\n    });\n  }\n});\n\n\n\n//# sourceURL=webpack:///./src/a-tile.js?");

/***/ }),

/***/ "./src/all.js":
/*!********************!*\
  !*** ./src/all.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./a-location.js */ \"./src/a-location.js\");\n__webpack_require__(/*! ./a-building.js */ \"./src/a-building.js\");\n__webpack_require__(/*! ./a-tile.js */ \"./src/a-tile.js\");\n__webpack_require__(/*! ./a-terrain.js */ \"./src/a-terrain.js\");\n\n\n//# sourceURL=webpack:///./src/all.js?");

/***/ })

/******/ });